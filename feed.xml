<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://github.com/Ahranah/feed.xml" rel="self" type="application/atom+xml"/><link href="https://github.com/Ahranah/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-18T18:28:08+00:00</updated><id>https://github.com/Ahranah/feed.xml</id><title type="html">Ahranah</title><subtitle>Backend Engineer | FinTech | Security</subtitle><entry><title type="html">[Oracle] 오라클 시간 처리 문법 정리</title><link href="https://github.com/Ahranah/blog/2025/Oracle-%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%8B%9C%EA%B0%84-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="[Oracle] 오라클 시간 처리 문법 정리"/><published>2025-12-16T15:48:24+00:00</published><updated>2025-12-16T15:48:24+00:00</updated><id>https://github.com/Ahranah/blog/2025/Oracle-%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%8B%9C%EA%B0%84-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/Oracle-%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%8B%9C%EA%B0%84-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/59413?language=oracle">입양 시각 구하기(2) Lv 4</a></p> <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/59413?language=oracle">프로그래머스SW개발자를 위한 평가, 교육의 Total Solution을 제공하는 개발자 성장을 위한 베이스캠프programmers.co.kr</a></p> <ul> <li>DB에 없는 값을 시간은 만들어서 반환해야 함 -&gt; Recursive CTE or CONNECT BY LEVEL</li> <li>시간 추출: mysql은 hour()로 할 수 있지만 오라클은 형 명시해줘야함</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-12-17-oracle-%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%8B%9C%EA%B0%84-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/img.png" sizes="95vw"/> <img src="/assets/img/posts/2025-12-17-oracle-%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%8B%9C%EA%B0%84-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Mysql 버전</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span> <span class="k">RECURSIVE</span> <span class="n">TIME_MAP</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="mi">0</span> <span class="k">AS</span> <span class="n">hour</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="n">hour</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">TIME_MAP</span> <span class="k">WHERE</span> <span class="n">hour</span> <span class="o">&lt;</span> <span class="mi">23</span>
<span class="p">)</span>

<span class="k">SELECT</span> 
    <span class="n">t</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span>                <span class="c1">-- 기준 테이블(t)의 시간을 선택</span>
    <span class="k">COUNT</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">animal_id</span><span class="p">)</span>     <span class="c1">-- ID가 없으면 0으로 세야 하므로 COUNT(*) 대신 컬럼 명시</span>
<span class="k">FROM</span> <span class="n">TIME_MAP</span> <span class="n">t</span>            <span class="c1">-- 시간 테이블이 '왼쪽'이어야 함</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">ANIMAL_OUTS</span> <span class="n">a</span> 
    <span class="k">ON</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span> <span class="o">=</span> <span class="n">HOUR</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nb">datetime</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span>            <span class="c1">-- 기준 테이블(t) 기준으로 그룹핑</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span><span class="p">;</span>
</code></pre></div></div> <p>오라클 버전</p> <ul> <li>recursive CTE -&gt; Connect by level 라는 계층형 쿼리로 변환해서 사용한다.Connect by는 ~ 조건이 될 때까지처럼 사용 가능, 내부적으로 level (무조건 1부터 시작)을 만들어서 카운트하기 때문에 이를 recursive 대신 사용한다.근데 이 때 from이 없으면 에러나기 때문에 내부에서 지원하는 dual(dummy table)을 써준다.</li> <li>오라클도 CTE 지원한다.</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 코드를 입력하세요</span>
<span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">animal_id</span><span class="p">)</span> <span class="k">as</span> <span class="k">count</span>
<span class="k">from</span> <span class="p">(</span>
    <span class="k">select</span> <span class="k">level</span><span class="o">-</span><span class="mi">1</span> <span class="k">as</span> <span class="n">hour</span> <span class="c1">-- level은 1부터 시작</span>
    <span class="k">from</span> <span class="n">dual</span>
    <span class="k">connect</span> <span class="k">by</span> <span class="k">level</span> <span class="o">&lt;=</span> <span class="mi">24</span>
<span class="p">)</span> <span class="n">t</span>
<span class="k">left</span> <span class="k">join</span> <span class="n">animal_outs</span> <span class="n">a</span> 
<span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span> <span class="o">=</span> <span class="n">to_number</span><span class="p">(</span><span class="n">to_char</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nb">datetime</span><span class="p">,</span> <span class="s1">'HH24'</span><span class="p">))</span>
<span class="k">group</span> <span class="k">by</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span>
<span class="k">order</span> <span class="k">by</span> <span class="n">t</span><span class="p">.</span><span class="n">hour</span>
</code></pre></div></div> <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/131534">상품을 구매한 직원 회원 비율 구하기</a></p> <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/131534">프로그래머스SW개발자를 위한 평가, 교육의 Total Solution을 제공하는 개발자 성장을 위한 베이스캠프programmers.co.kr</a></p> <p>21년에 가입한 사람과, 21년에 가입한 사람 중 물건을 산 사람의 비율을 소수점 두번째자리에서 반올림해서 반환해야 한다.</p> <ul> <li>가입한 사람의 전체 인원 수는, 메인에서 Where로 조건 걸면 join 물건 산 사람할때 전체 인원 수가 날라가고, 구매한 사람 수만 남기 때문에 전체 인원수는 서브쿼리로 독립적으로 숫자를 세줘야 한다.</li> </ul> <p>오라클 준비물</p> <p>분류 코드 설명 예시 (2025-12-05 14:05:09)</p> <p>연도 YYYY 4자리 연도 2025</p> <p>YY 2자리 연도 25</p> <p>월 MM 2자리 월 (숫자) 12</p> <p>MON 월 이름 (약어) DEC (영문판), 12월 (한글판)</p> <p>일 DD 2자리 일 05</p> <p>요일 DY 요일 약어 THU, 목</p> <p>DAY 요일 전체 THURSDAY, 목요일</p> <p>시간 HH24 24시간제 (0-23) 14</p> <p>HH 12시간제 (1-12) 02</p> <p>분 MI 분 (Minute) 05 (MM 아님! 주의)</p> <p>초 SS 초 (Second) 09</p> <ul> <li>MM을 char로 뽑으면 03, 05이렇게 0이 붙어나와서 to_number 필요</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">TO_CHAR</span><span class="p">(</span><span class="n">SYSDATE</span><span class="p">,</span> <span class="s1">'YYYY-MM-DD HH24:MI:SS'</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">DUAL</span><span class="p">;</span>
<span class="c1">-- 결과: 2025-12-05 14:05:09</span>

<span class="k">SELECT</span> 
    <span class="n">to_char</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">sales_date</span><span class="p">,</span> <span class="s1">'YYYY'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">year</span><span class="p">,</span>
    <span class="n">to_number</span><span class="p">(</span><span class="n">to_char</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">sales_date</span><span class="p">,</span> <span class="s1">'MM'</span><span class="p">))</span> <span class="k">as</span> <span class="k">month</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">purchased_users</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span> <span class="o">/</span> 
          <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">user_info</span> <span class="k">where</span> <span class="n">to_char</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="s1">'YYYY'</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'2021'</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">purchased_ratio</span>
<span class="k">from</span> <span class="n">user_info</span> <span class="n">a</span>
<span class="k">join</span> <span class="n">online_sale</span> <span class="n">o</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">user_id</span> 
<span class="k">where</span> <span class="n">to_char</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">joined</span><span class="p">,</span> <span class="s1">'YYYY'</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'2021'</span>
<span class="k">group</span> <span class="k">by</span> <span class="n">to_char</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">sales_date</span><span class="p">,</span> <span class="s1">'YYYY'</span><span class="p">),</span> <span class="n">to_char</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">sales_date</span><span class="p">,</span> <span class="s1">'MM'</span><span class="p">)</span>
<span class="k">order</span> <span class="k">by</span> <span class="nb">year</span><span class="p">,</span> <span class="k">month</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="프로그래머스"/><category term="Oracle"/><category term="CONNECT_BY"/><summary type="html"><![CDATA[입양 시각 구하기(2) Lv 4]]></summary></entry><entry><title type="html">프림스트라, 프림과 다익스트라 이해하기</title><link href="https://github.com/Ahranah/blog/2025/%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="프림스트라, 프림과 다익스트라 이해하기"/><published>2025-12-11T08:12:34+00:00</published><updated>2025-12-11T08:12:34+00:00</updated><id>https://github.com/Ahranah/blog/2025/%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/"><![CDATA[<p>프림은 MST 최소비용 신장 트리를 만드는 알고리즘이고, 다익스트라는 최단경로를 만드는 알고리즘이다.</p> <ul> <li>Minimum Spanning Tree는 모든 정점이 연결되어 있고 가중치 합이 최소가 되는 트리를 말한다.</li> <li>그래프는 모든 정점이 연결되어 사이클이 생겨도 되는데, 이 중에서 acylic하면 트리라고 말한다.</li> </ul> <p>둘 다 PQ를 이용해 구현하고, 가중치의 최소를 뽑는 공통점 때문에 코딩테스트를 하다가 프림스트라를 구현하는 일이 적지 않다.</p> <p>결론을 말하면, PQ에 넣는 값이 다르다. 프림은 가중치가 담긴 노드(a -&gt; b)를 모두 PQ에 넣어놓고 가장 작은 가중치를 뽑는다.</p> <p>다익스트라는 현재까지 진행된 (다음 노드까지 이동한다고 가정했을 때의) 가중치의 합이 가장 작은 값을 PQ에서 뽑는다.</p> <h2 id="greedy">Greedy</h2> <p>프림과 다익스트라 모두 현재 상황에서 가장 좋은 선택지를 선택한다는 점에서 그리디 알고리즘 중 하나라고 볼 수 있다.</p> <p>그리디는 현재 상황에서 최적의 해를 선택하는 알고리즘인데, 지금의 최적이 결과로 봤을때도 최적의 해가 되지 않을 수 있다.</p> <ul> <li>거스름돈 반환 문제</li> </ul> <p>따라서, 그리디 알고리즘은 다음과 같은 3가지 절차를 거친다.</p> <ol> <li>Selection: Greedy한 해답을 Solution Set에 넣는다.</li> <li>Feasibility Check: 해답이 실행 가능한지 결정한다.</li> <li>Solution Check: 최적의 해가 되는지 확인한다.</li> </ol> <p>이를 최소비용 신장 트리로 예시를 들면,</p> <p>시작점 i를 선택하고, 모든 노드에 대해 방문 여부를 체크하는 boolean[]을 만든다.</p> <ol> <li>(시작 노드, 종료 노드, 가중치)를 PQ에 넣을건데,PQ의 조건은 가중치를 우선순위로 둔다.</li> <li>현재 노드 i에 대해이동 가능한 노드만 PQ에 넣는다.</li> <li>최적의 해가 되는지 확인하는 절차는, 순환하지 않음을 증명하면 되는데 이동 가능한 노드의 조건을 지금 노드와 연결된 노드 중에서, 방문하지 않은 노드만을 조건으로 하면 된다.</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/img.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>프림은</p> <ol> <li>b에서 시작하면, PQ에 (a, d)를 넣고 d를 선택한다. 그리고 d를 방문 처리한다.</li> <li>d에서 이동가능한 (c, d, f)를 넣고 e를 선택, … e-&gt; c -&gt; a -&gt; f</li> <li>f를 고르게 되는 건 a에서 이동가능한 점이 없어서 PQ에 있던 f를 선택하게 된다.</li> </ol> <p>다익스트라는 일단 프림과 목적이 다르다. MST에 쓰는 게 아니라, 특정 위치에 도달하는 최단 거리를 구하는 것이다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/img_1.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/img_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/img_2.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/img_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ol> <li>PQ의 우선순위를 가중치의 합으로 둔다.</li> <li>현재 갈 수 있는 (방문하지 않은) 노드까지 가중치를 누적해서 PQ에 넣는다.</li> <li>최적의 해는, Math.min으로 항상 갱신한다.</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/Screenshot%202025-12-11%20at%203.51.39%E2%80%AFPM.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/2025-12-11-%ED%94%84%EB%A6%BC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%ED%94%84%EB%A6%BC%EA%B3%BC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/Screenshot%202025-12-11%20at%203.51.39%E2%80%AFPM.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>위와 같은 경우는, 1, 2번인 그리디 선택과 이동 가능이 모두 만족한 사례다. 이를 위해 최적의 해로 최소값을 계속 갱신해준다.</p>]]></content><author><name></name></author><category term="Algorithm"/><category term="다익스트라"/><category term="프림"/><category term="그리디"/><summary type="html"><![CDATA[프림은 MST 최소비용 신장 트리를 만드는 알고리즘이고, 다익스트라는 최단경로를 만드는 알고리즘이다.]]></summary></entry><entry><title type="html">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</title><link href="https://github.com/Ahranah/blog/2025/1334-Find-the-City-With-the-Smallest-Number-of-Nei/" rel="alternate" type="text/html" title="1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"/><published>2025-12-10T15:32:11+00:00</published><updated>2025-12-10T15:32:11+00:00</updated><id>https://github.com/Ahranah/blog/2025/1334-Find-the-City-With-the-Smallest-Number-of-Nei</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/1334-Find-the-City-With-the-Smallest-Number-of-Nei/"><![CDATA[<p><a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/">Find the City With the Smallest Number of Neighbors at a Threshold Distance - LeetCode</a></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheCity</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distanceThreshold</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dist_dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        
        
        <span class="c1">// 초기화</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 오버플로우 조심</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">100001</span><span class="o">);</span>
            <span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// w로 채우기</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

                <span class="n">dist_dp</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
                <span class="n">dist_dp</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
        <span class="o">}</span>        

        <span class="c1">// 플로이드 워셜로 경로 최솟값 업데이트</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>

                    <span class="k">if</span><span class="o">(</span><span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist_dp</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span>
                        <span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">dist_dp</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 노드마다 가는 길 카운트하고, </span>
        <span class="c1">// 최소카운트면, 답 노드 최댓값으로 </span>
        <span class="kt">int</span> <span class="n">minReachable</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">!=</span><span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">dist_dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">distanceThreshold</span><span class="o">){</span>
                    <span class="n">count</span> <span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">minReachable</span><span class="o">){</span>
                <span class="n">minReachable</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <ul> <li>초기화할때 Integer.MAX_VALUE 오버플로우나서 오류 → 10001로 수정</li> </ul>]]></content><author><name></name></author><category term="Algorithm"/><category term="Leetcode"/><category term="dp"/><summary type="html"><![CDATA[Find the City With the Smallest Number of Neighbors at a Threshold Distance - LeetCode]]></summary></entry><entry><title type="html">프로그래머스 완전탐색 전력망 둘로 나누기</title><link href="https://github.com/Ahranah/blog/2025/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%EC%A0%84%EB%A0%A5%EB%A7%9D-%EB%91%98%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0/" rel="alternate" type="text/html" title="프로그래머스 완전탐색 전력망 둘로 나누기"/><published>2025-12-10T15:11:56+00:00</published><updated>2025-12-10T15:11:56+00:00</updated><id>https://github.com/Ahranah/blog/2025/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%EC%A0%84%EB%A0%A5%EB%A7%9D-%EB%91%98%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%EC%A0%84%EB%A0%A5%EB%A7%9D-%EB%91%98%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0/"><![CDATA[<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">wires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">adj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">wires</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">wires</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">wires</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">a</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">b</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="o">}</span>
        
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">wires</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">wires</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">wires</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>

            <span class="n">adj</span><span class="o">[</span><span class="n">a</span><span class="o">].</span><span class="na">remove</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">b</span><span class="o">].</span><span class="na">remove</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">a</span><span class="o">));</span>

            <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">adj</span><span class="o">);</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">count</span><span class="o">)</span> <span class="o">-</span> <span class="n">count</span><span class="o">));</span>

            <span class="n">adj</span><span class="o">[</span><span class="n">a</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span> <span class="c1">// 복원</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">b</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span> <span class="c1">// 복원</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">v</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">list</span><span class="o">){</span>
        <span class="n">v</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// if(list[node].size()==0) return 0;</span>
        
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">list</span><span class="o">[</span><span class="n">node</span><span class="o">]){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <ul> <li>DFS로 노드 개수 세는 건 count += dfs(next) 형태로 누적.</li> <li>remove(int index)와 remove(Object o) 중값 제거를 하려면 객체로 감싸야 함.</li> </ul>]]></content><author><name></name></author><category term="Algorithm"/><category term="프로그래머스"/><category term="완전탐색"/><summary type="html"><![CDATA[```java import java.util.*;]]></summary></entry><entry><title type="html">[Java][BOJ 11650] 좌표 (퀵)정렬하기</title><link href="https://github.com/Ahranah/blog/2025/Java-BOJ-11650-%EC%A2%8C%ED%91%9C-%ED%80%B5-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Java][BOJ 11650] 좌표 (퀵)정렬하기"/><published>2025-10-08T14:59:38+00:00</published><updated>2025-10-08T14:59:38+00:00</updated><id>https://github.com/Ahranah/blog/2025/Java-BOJ-11650-%EC%A2%8C%ED%91%9C-%ED%80%B5-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/Java-BOJ-11650-%EC%A2%8C%ED%91%9C-%ED%80%B5-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="문제-링크">문제 링크</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/Boj/2025-10-08-java-boj-11650-%EC%A2%8C%ED%91%9C-%ED%80%B5-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/img.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/Boj/2025-10-08-java-boj-11650-%EC%A2%8C%ED%91%9C-%ED%80%B5-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>pivot을 정하면 그 위치는 딱 하나인데, 왜 확률을 곱해서 평균을 내지? 그때그때 n-1번 비교하는 거 아닌가요?</p> <p>-&gt; 그때그때 어떤 pivot이 선택될지 모르기 때문에 모든 경우를 평균적으로 고려해서 E[X] 계산을 하는거다.</p> <p>만약 제일 작은 요소를 pivot으로 선택하면 왼쪽은 크기가 0, 오른쪽은 크기가 n-1이 부분 배열이 생겨서 최악의 시간 복잡도를 가진다.</p> <h2 id="문제-파악">문제 파악</h2> <p>2차원 평면 위의 점 N개를 x좌표, y좌표 순으로 증가하도록 정렬하라.</p> <ul> <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.</li> </ul> <p>x 순으로 정렬하고, x가 같을 때 y를 비교하도록 한다.</p> <ul> <li>분할 -&gt; 정복(정렬), 같을 때 분할 -&gt; 정복(정렬)</li> </ul> <h2 id="접근-방법">접근 방법</h2> <p><strong>1. mergeSort</strong></p> <p>원래 배열을 둘로 나누고, 나뉜 두 개의 배열을 비교해서 합치면서 정렬한다.</p> <ol> <li>N의 중간값을 기준으로 배열 1, 배열 2로 나누어 받는다.</li> <li>재귀를 이용해 배열 하나에 [x, y]만 남도록 partition한다.</li> <li>merge: 공통 배열에 배열 1과 2의 x값을 비교해 작은 값을 넣는다.</li> <li>만약 같다면 y값을 비교해 더 작은 것이 앞으로 가도록 한다.</li> </ol> <p><strong>2. quickSort</strong></p> <p>하나의 pivot을 무작위로 구해서, pivot 기준으로 좌측은 pivot보다 작게, 우측은 크게해서 배열을 둘로 쪼개고, 쪼개진 배열에서도 위와 같이 pivot을 구해 정렬한다.</p> <ol> <li>pivot을 선정해 pivot의 위치와 pivot 값을 기록한다.</li> <li>i, j = 0 으로 놓는다. i는 for문을 도는값, j는 피벗보다 작은 값이 들어갈 범위의 마지막 인덱스다.</li> <li>for문으로 배열의 [pivot index+1, ] 범위를 pivot item과 비교해 더 작으면 pivot과 swap한다.pivot과 동일하면 y값을 비교한다.pivot보다 작은 값이 들어갈 위치는 이전 마지막 인덱스 j 에  +1 해서 swap한다.</li> <li>pivot이 들어가야할 최종 위치 j와 pivot이 원래 있었던 위치를 swap한다.</li> </ol> <p>최종적으로 왼쪽은 pivot보다 작은 값, 오른쪽은 큰 값이 되었다. 이걸 partition 배열의 개수가 2인 칸까지 Top down한다 생각하면, 전체 sorting이 된다.</p> <h2 id="코드-구현">코드 구현</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">Node</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
        <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="nc">Node</span><span class="o">[]</span> <span class="no">S</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">){</span>
        <span class="nc">Node</span> <span class="n">pivotItem</span> <span class="o">=</span> <span class="no">S</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">low</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span> <span class="o">&lt;</span> <span class="n">pivotItem</span><span class="o">.</span><span class="na">x</span> <span class="o">||</span> <span class="o">(</span><span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span> <span class="o">==</span> <span class="n">pivotItem</span><span class="o">.</span><span class="na">x</span> <span class="o">&amp;&amp;</span> <span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">y</span> <span class="o">&lt;</span> <span class="n">pivotItem</span><span class="o">.</span><span class="na">y</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
                <span class="n">swap</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">swap</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="nc">Node</span><span class="o">[]</span> <span class="no">S</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">pivotPoint</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pivotPoint</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="n">pivotPoint</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="nc">Node</span><span class="o">[]</span> <span class="no">S</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">quickSort</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="nl">n:</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">x</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">y</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="c1">// System.out.println(n.x + " " + n.y); // IO마다 호출해서 느림</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">sb</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="배우게-된-점">배우게 된 점</h2> <p>시간초과났지만 알고리즘이니까 이러케 풀겠따.</p> <p>Java 내장 정렬로 아주 간단히 풀 수도 있다. 이렇게하면 시간초과 안난다.</p> <ul> <li>Arrays.sort()는Dual-Pivot QuickSort로 평균 성능 매우 우수</li> <li>JVM이 최적화 해줌 (입력 정렬 상태에 따라 다른 알고리즘 사용)</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">x</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
        <span class="o">});</span>
</code></pre></div></div> <h2 id="질문">질문</h2>]]></content><author><name></name></author><category term="Algorithm"/><category term="백준"/><category term="퀵정렬"/><category term="분할정복"/><summary type="html"><![CDATA[문제 링크]]></summary></entry><entry><title type="html">정렬 시간 복잡도는 왜 W(n) = W(n/2) + 1인가</title><link href="https://github.com/Ahranah/blog/2025/%EC%A0%95%EB%A0%AC-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%8A%94-%EC%99%9C-W-n-W-n-2-1%EC%9D%B8%EA%B0%80/" rel="alternate" type="text/html" title="정렬 시간 복잡도는 왜 W(n) = W(n/2) + 1인가"/><published>2025-10-06T14:36:02+00:00</published><updated>2025-10-06T14:36:02+00:00</updated><id>https://github.com/Ahranah/blog/2025/%EC%A0%95%EB%A0%AC-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%8A%94-%EC%99%9C-W-n-W-n-2-1%EC%9D%B8%EA%B0%80</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/%EC%A0%95%EB%A0%AC-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%8A%94-%EC%99%9C-W-n-W-n-2-1%EC%9D%B8%EA%B0%80/"><![CDATA[<p>분할정복에서 파생하는 합병정렬, 퀵정렬 모두 시간복잡도 계산에서 W(n) = W(n/2) + 1를 가정하고 계산한다.</p> <p>분할 정복의 기초, 이진 재귀 탐색은 아래와 같은 구조를 자주 사용한다.</p> <p>배열 S → 반으로 나누고 → 재귀적으로 처리 → 합치기</p> <p>W(n)은 n개의 데이터 중 하나를 찾는 데 걸리는 <strong>단계 수 or 비교 횟수</strong>를 의미한다.</p> <p>배열을 정확히 반씩 쪼갤 수 있을 때 한 번 나누면 2등분이 되고 그 중 절반만 확인하면 되니, 비교 횟수는 1번씩만 증가한다.</p> <p>완벽히 반으로 나눌 수 있을 때, 각 깊이마다 딱 1번의 비교를 하므로, W(n) = W(n/2) + 1</p> <p>이렇게 완벽히 반으로 나눌 수 있는 상황이 2이 거듭제곱(n = 2^k)일 때니, 재귀 깊이는 log₂(n)이 된다.</p> <p>⇒ W(n) = log₂(n) + 1 ∈ Θ(log n)</p>]]></content><author><name></name></author><category term="Algorithm"/><category term="정렬"/><category term="이진재귀"/><summary type="html"><![CDATA[분할정복에서 파생하는 합병정렬, 퀵정렬 모두 시간복잡도 계산에서 W(n) = W(n/2) + 1를 가정하고 계산한다.]]></summary></entry><entry><title type="html">[Servlet] 웹 애플리케이션 기본 구조와 Servlet 라이프사이클</title><link href="https://github.com/Ahranah/blog/2025/Servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-Servlet-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/" rel="alternate" type="text/html" title="[Servlet] 웹 애플리케이션 기본 구조와 Servlet 라이프사이클"/><published>2025-07-07T13:37:16+00:00</published><updated>2025-07-07T13:37:16+00:00</updated><id>https://github.com/Ahranah/blog/2025/Servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-Servlet-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/Servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-Servlet-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"><![CDATA[<h2 id="웹-애플리케이션-개발을-위한-웹-기본-동작-원리를-익혀본다">웹 애플리케이션 개발을 위한 웹 기본 동작 원리를 익혀본다.</h2> <h2 id="1-네트워크-http">1. 네트워크: HTTP</h2> <p>웹은 HTTP라는 프로토콜을 기반으로 브라우저와 서버가 메시지를 주고 받으면서 동작한다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img.png" sizes="95vw"/> <img src="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>브라우저가 HTML을 통해 서버에 요청(request)을 전달하면 서버는 request와 함께 전달된 사용자 정보를 추출해서 요청된 기능을 처리한다. 이때 서버에서 사용자 request를 처리하는 대표적인 자바 기술이 Servlet이다.</p> <ul> <li>서블릿은 Spring MVC에서도 이어지는 개념이니 용어가 익숙해져야 한다.</li> </ul> <p>웹 앱 개발은 TCP 기반의 HTTP를 이해하는 것으로 시작한다. 네트워크 사용할 때 사용하는 통신 규약이므로 웹 프로그래밍 개발을 위해 동작 원리를 익혀야 한다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img_1.png" sizes="95vw"/> <img src="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>히히 끼워팔기</p> <p><a href="https://ahranah.tistory.com/88">TCP/IP 와 UDP*이것이 자바다(3판)을 보고 작성한 글입니다.IP: Internet ProtocolIP 주소는 네트워크 어댑터(LAN 카드)마다 할당된다.DNS(Domain Name System)Web browser 웹 명령어 ipconfig / ifconfig웹브라우저가 DNS를 거쳐 웹서ahranah.tistory.com</a></p> <p><a href="https://ahranah.tistory.com/58">HTTP Protocol 기초*Node.js 프로그래밍 입문(고경희)를 읽고 작성한 글입니다.  클라이언트는 서버로 자료를 요청하고, 서버는 클라이언트로 자료를 전송하는 방식으로 웹이 동작한다. HTTP requestHTTP response 근데ahranah.tistory.com</a></p> <h2 id="2-서버의-구성-톰캣과-서블릿">2. 서버의 구성: 톰캣과 서블릿</h2> <p>앞서, 서버가 클라이언트의 request를 처리하는 대표적인 기술이 서블릿이라 했다.</p> <p>서블릿은 JSP와 함께 동적 콘텐츠를 작성할 수 있는 자바 기술이다. 서버를 구성하는 부품은 자바로 구현 가능한 것으로 이뤄지는데, 자바로 구현한 웹 애플리케이션은 기본적으로 서버 사이의 이식성이 보장되기 때문이다.</p> <p>톰캣 서버를 기반으로 개발된 웹 앱은 제우스나 웹로직 같은 다른 서버에서 실행해도 동일하게 실행된다. 이렇게 서버 사이의 이식성을 보장하기 위해서 기본적으로 웹앱이 모든 서버가 인식하는 정형화된 디렉터리 구조를 유지해야만 한다.</p> <ul> <li>서버 사이 이식성을 보장하기 위해 자바로 구현한 Servlet, Tomcat 서버를 이용한다.</li> <li>서버 사이 이식성을 보장하기 위해 정형화된 디렉토리 구조를 유지한다.</li> </ul> <h3 id="2-1-서버-동작의-개요">2-1. 서버 동작의 개요</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img_2.png" sizes="95vw"/> <img src="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>웹 애플리케이션 컨테이너(예: Tomcat, Jetty)는 서블릿이 안정적으로 실행되기 위한 공통 환경을 제공한다. 구체적으로는 HTTP 요청·응답을 관리하고, 서블릿의 생성·초기화·소멸(lifecycle)을 제어하며, 보안·트랜잭션 같은 엔터프라이즈 기능을 대신 처리한다. 개발자는 이 복잡한 기반 구조를 직접 구현할 필요 없이 비즈니스 로직에만 집중할 수 있다.</p> <ul> <li>쇼핑몰 장바구니 할인에서 아래와 같은 내용이 비즈니스 로직이다.사용자가 장바구니에 담은 상품들의 가격과 수량을 합산해총 주문금액을 계산할인 적용 기준 검사 - 계산된 금액이 “10만원 이상”이면10% 할인을 적용</li> </ul> <p>서블릿을 여러 개로 나누는 이유는 관심사의 분리(Separation of Concerns)와 재사용성 때문이다. 예를 들어 “로그인 처리”, “게시판 목록 조회”, “파일 업로드” 같은 기능을 각각의 서블릿 클래스로 구현하면 유지보수가 쉽고, URL 맵핑을 통해 기능별로 요청을 간편히 분배할 수 있다. 각 서블릿은 자신에게 맡겨진 책임만 수행하기 때문에 테스트·디버깅도 명확해진다.</p> <p>컨테이너는 실행 환경을 표준화하고, 서블릿 분리는 모듈화를, 멀티스레드는 성능 최적화</p> <ol> <li>클라이언트 요청웹 브라우저가 특정 URL로 HTTP 요청을 보냄요청은 먼저 웹 서버(예: Apache httpd, Nginx)로 들어감</li> <li>서블릿 컨테이너 전달웹 서버는 요청을 서블릿 컨테이너(예: Tomcat)의 접속 포트로 포워딩컨테이너는 요청 URL에 매핑된Servlet클래스를 찾음</li> <li>서블릿(Servlet) 실행doGet()/doPost()메소드에서 비즈니스 로직 수행필요 시 DB와 연동하여 데이터 조회·가공조회한 결과를request.setAttribute(“data”, 값)등에 담아 JSP로 전달</li> <li>JSP 호출 및 화면 결합서블릿이RequestDispatcher.forward(“/view.jsp”)로 JSP 실행 지시JSP는 HTML 템플릿 코드에 서블릿에서 설정한request데이터를 삽입하여 동적 페이지(HTML) 생성</li> <li>응답 반환생성된 HTML은 다시 서블릿 컨테이너 → 웹 서버 → 클라이언트 순으로 전송브라우저가 수신한 HTML을 렌더링</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img_3.png" sizes="95vw"/> <img src="/assets/img/posts/2025-07-07-servlet-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-servle/img_3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>멀티스레드 지원하여 한 대의 서버 프로세스에서 수십, 수백 개의 요청을 동시에 처리할 수 있다. 쓰레드 풀에서 각각의 요청을 병렬 처리하여 다수 요청에서 응답 지연을 줄인다. 단, 스레드 간 공유 자우너에 대한 동기화 처리가 필요해 코드가 복잡해지고, 교착 상태나 race condition을 주의해야 한다.</p> <ul> <li>단일 스레드: 순차적 처리 → 구현이 단순하고 디버깅이 쉬우나, 동시 접속이 늘어나면 대기 시간 증가</li> <li>멀티스레드: 병렬 처리 → 처리량이 높고 확장성이 좋으나, 동시성 제어와 컨텍스트 스위칭 비용을 고려해야 함</li> </ul> <p>*채쌤의 Servlet&amp;JSP 프로그래밍 핵심(채큐태)를 읽고 작성한 글입니다.</p>]]></content><author><name></name></author><category term="KB_ITs_Your_Life_6th"/><summary type="html"><![CDATA[웹 애플리케이션 개발을 위한 웹 기본 동작 원리를 익혀본다.]]></summary></entry><entry><title type="html">2025 제 10회 빅데이터분석기사 실기 합격 후기</title><link href="https://github.com/Ahranah/blog/2025/2025-%EC%A0%9C-10%ED%9A%8C-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/" rel="alternate" type="text/html" title="2025 제 10회 빅데이터분석기사 실기 합격 후기"/><published>2025-07-04T08:57:08+00:00</published><updated>2025-07-04T08:57:08+00:00</updated><id>https://github.com/Ahranah/blog/2025/2025-%EC%A0%9C-10%ED%9A%8C-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/2025-%EC%A0%9C-10%ED%9A%8C-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-07-04-2025-%EC%A0%9C-10%ED%9A%8C-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/img.png" sizes="95vw"/> <img src="/assets/img/posts/2025-07-04-2025-%EC%A0%9C-10%ED%9A%8C-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>[해명] 3유형 안버리고 공부했는데.. 시험장에서 ols 옆에 .fit() 붙이는거를 help, dir로 못 찾아서 아예 백지로 냈다.</p> <h2 id="빅데이터-분석기사-실기란">빅데이터 분석기사 실기란</h2> <p>실기는 기출에 나오는 유형별 라이브러리 모델 하나씩 외워서 쓰면 되는 시험이다.</p> <p>돈 안쓰고 공부하려고 보면 어떤 시험인지, 어느 정도 공부해야 하는지 감 잡기가 어려워 시간 낭비하기 쉽다. 나도 자격증 딸 때 강의에 돈 쓰는 거 아까워하는 편이라 무료 자료, 강의를 많이 찾아봤다. 그런데 데이터 분석이라는 한 분야를 시험으로 본다는 게,, 엄청난 공부량이 필요할 것 같았다. 겁 먹지 않아도 된다. 아래 포스트에 정리된 내용만 봐도 충분히 통과할 수 있다.</p> <p>어떤 시험이고, 어떻게 준비하고, 어떤 라이브러리, 함수를 쓰는지 잘 정리된 블로그다.</p> <p><a href="https://velog.io/@imymemineyay/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EC%A4%80%EB%B9%84-%EC%8B%A4%EA%B8%B0-%EC%A0%95%EB%B3%B4-%EB%B0%8F-7%EC%9D%BC-%EA%B3%B5%EB%B6%80-%EA%B3%84%ED%9A%8D">빅데이터분석기사 실기 준비① - 실기 정보 및 7일 공부 계획빅데이터분석기사 실기 정보와 공부법 및 참고 자료 공유합니다.velog.io</a></p> <h2 id="공부-방법">공부 방법</h2> <p>5일동안 데이터 마님 전처리, 2유형, 3유형 + 8회 기출 풀었다. 파이썬이 주 언어가 아니어서 감잡으려고 1유형 전처리 부분을 2회독했다.</p> <p><a href="https://www.datamanim.com/dataset/99_pandas/pandasMain.html#google_vignette">판다스 연습 튜토리얼 — DataManim판다스 연습 튜토리얼 10회 빅분기 실기 대비 강의, 블로그만으로는 도저히 안되겠다ㅠ 하시는분들에게 추천합니다. 아 제발 광고 한번씩만 눌러주세요 ㅠㅠ 두번은 더 좋구요 오픈톡방 (pw: dbscawww.datamanim.com</a></p> <h4 id="1-유형-데이터-탐색-전처리">1 유형: 데이터 탐색, 전처리</h4> <p>1유형 데이터 전처리 부분은 2, 3 유형에서도 활용되니까 확실히 잡아놓는 것이 좋을 것 같다.</p> <p>전처리 풀면서 오답노트 했던 노션이다. 저번 9회 실기에서 그룹핑 해체, 분열(unstack melt)가 어려웠다는 후기글이 있었다.</p> <p>이번 10회 실기는 시간데이터 연-월 단위 그룹핑이 나왔다. pivot은 안나왔다.</p> <table> <tbody> <tr> <td>[Preprocessing</td> <td>Notion1. Getting &amp; Knowing Datawww.notion.so](https://www.notion.so/ahranah/Preprocessing-20e1f17a603780739b66c236ec119e94?source=copy_link)</td> </tr> </tbody> </table> <h4 id="2-유형-모델링">2 유형: 모델링</h4> <p>2유형은 데이터 분석 전 과정을 구현하는 유형이다. 10번 정도만 클론 코딩해도 흐름은 외우니까 크게 겁먹지 않아도 된다.</p> <p>분류, 회귀 문제 유형별로 모델 하나만 쓰겠다는 생각으로 공부했다.</p> <p>모델로 RandomForest 계열을 쓰면 인코딩에서 자유로워지고, 하이퍼 파라미터 튜닝도 (test size 제외) 크게 성능에 영향이 없다.</p> <p>이번 시험에서는 결측치, 전처리없는 회귀문제가 나왔고 rmse로 평가하는 건데 모델 하나밖에 몰라서 인코딩으로 차이를 뒀다.</p> <p>그래서 여유가 된다면 모델 두 개 정도는 외워서 평가 지표로 모델을 선택하는 것도 괜찮을 것 같다.</p> <table> <tbody> <tr> <td>[제 2유형</td> <td>NotionGoogle Colabwww.notion.so](https://www.notion.so/ahranah/2-2161f17a6037803a9356cfcc9354245f?source=copy_link)</td> </tr> </tbody> </table> <h4 id="3-유형-검정">3 유형: 검정</h4> <p>어떻게 공부해야 하는지 가장 헤맸던 유형이다. 결론부터 말하면 9회 기출이랑 거의 똑같이 나왔다.</p> <p>3유형은 무료 해설 강의도 거의 없고, 기출 자료도 거의 없어서 존재하는 유튜브 강의를 최대한 활용했다.</p> <ol> <li> <p><a href="https://www.youtube.com/watch?v=wvvs7S9On0w">https://www.youtube.com/watch?v=wvvs7S9On0w</a></p> </li> <li> <p><a href="https://www.youtube.com/watch?v=9mcnKbCbchk">https://www.youtube.com/watch?v=9mcnKbCbchk</a></p> </li> </ol> <p>위 두 영상을 보면서 감을 잡아갔다.</p> <p><a href="https://ourjune.tistory.com/53">3. https://ourjune.tistory.com/53</a></p> <p><a href="https://ourjune.tistory.com/53">[빅분기] 빅데이터 분석기사 3유형 벼락치기 요약 정리모듈 및 함수 불러오기scipy.stats T-test(단일표본 ttest_1samp, 독립표본 ttest_ind, 대응표본 ttest_rel), 카이제곱검정(chi2_contingency 독립성검정, chisquare 적합도 검정), ANOVA(다원분산분석은 statsmodel이 더 좋ourjune.tistory.com</a> 이 분 블로그가 정말 도움이 많이 됐다. 흐름을 보면 메타코드 강의를 듣고 정리하신 것 같다. 양 추리고 흐름 잡기에 좋다.</p> <p>근데 최근에 난이도가 높아졌대서 안그래도 검정 파트가 양이 많은데 공부를 다 할 수 있을지 불안했다. 이번 시험이 9회랑 비슷하게 나온걸로 봐서 F검정까지만 봐도 되지 않을까 싶다. 특히나 시간이 없다면 statsmodel.api logit, ols 사용법만 제대로 외우면 문제 하나는 맞힐 수 있다.</p> <p>나는 시간상 전체 한 번 훑고 가는 게 목표였다. 마지막에 formula 공부하면서 statsmodel 이랑 statsmodel.api 사용법이 짬뽕돼서 아예 못 풀었다. 시험장에서 마지막까지 help, dir로 계속 찾았는데도 ols.fit() 이건 안나오더라(심한욕)</p> <p>모델을 아예 못 사용했으니 시험 떨어질 수도 있겠다는 생각에 넘 우울했다.. 운이 좋게 1, 2유형을 다 맞아서 붙었다. 다행이다.</p> <table> <tbody> <tr> <td>[제 3유형</td> <td>Notion메타코드M 빅데이터분석기사 실기 3유형 문제풀이 (2024 버전) - [가설검정, 모집단, 정규성]www.notion.so](https://www.notion.so/ahranah/3-2161f17a603780deaed0e4ebd32ce4f1?source=copy_link)</td> </tr> </tbody> </table> <p>####</p> <h2 id="시험-환경으로-모의고사-한-번-풀어보기">시험 환경으로 모의고사 한 번 풀어보기</h2> <p>나는 주어진 시간이 그리 많지 않았기 때문에 시험 환경에서 문제 푸는 연습을 못하고 갔다.</p> <p>VSCode로 하면 자동완성 기능이 있지만 시험 환경에는 없다. print()로만 결과를 출력할 수 있고, cell도 나누어져 있지 않다.</p> <p>내 생각엔 이번엔 정말 운이 좋았던거고 시험 환경에 대한 연습이 없으면 떨어질 수도 있을 것 같다.</p> <p>특히, help, dir로 각 라이브러리 사용법 어떻게 도출하는지 제대로 확인해보는 연습이 필요하다. 3유형의 경우엔 잘 안 찾아졌기 때문이다. 미리 해보면 차라리 제대로 외우고 가겠다는 마음이라도 생길 수 있다.</p>]]></content><author><name></name></author><category term="대내외활동"/><category term="자격증"/><category term="빅데이터분석기사"/><category term="빅분기"/><category term="빅데이터분석기사실기"/><category term="빅분기실기"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Java][BOJ 19941] 햄버거 분배</title><link href="https://github.com/Ahranah/blog/2025/Java-BOJ-19941-%ED%96%84%EB%B2%84%EA%B1%B0-%EB%B6%84%EB%B0%B0/" rel="alternate" type="text/html" title="[Java][BOJ 19941] 햄버거 분배"/><published>2025-06-26T04:42:50+00:00</published><updated>2025-06-26T04:42:50+00:00</updated><id>https://github.com/Ahranah/blog/2025/Java-BOJ-19941-%ED%96%84%EB%B2%84%EA%B1%B0-%EB%B6%84%EB%B0%B0</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/Java-BOJ-19941-%ED%96%84%EB%B2%84%EA%B1%B0-%EB%B6%84%EB%B0%B0/"><![CDATA[<h2 id="문제-링크">문제 링크</h2> <h2 id="문제-파악">문제 파악</h2> <p>식탁의 길이 N, 햄버거를 선택할 수 있는 거리 K, 사람과 햄버거의 위치가 주어졌을 때 햄버거를 먹을 수 있는 사람의 최대 수를 구하는 프로그램을 작성하시오. 첫 줄에 N과 K가 주어지고 다음 줄에 사람과 햄버거의 위치가 문자 P(사람)과 H(햄버거)로 주어진다.</p> <ul> <li>1 &lt;= N &lt;= 20000</li> <li>1 &lt;= K &lt;= 10</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">20</span> <span class="mi">1</span>
<span class="no">HHPHPPHHPPHPPPHPHPHP</span> <span class="c1">//8</span>

<span class="mi">20</span> <span class="mi">2</span>
<span class="no">HHHHHPPPPPHPHPHPHHHP</span> <span class="c1">//7</span>
</code></pre></div></div> <h2 id="접근-방법">접근 방법</h2> <p>햄버거 사람 햄버거 사람 햄버거 사람 햄버거 햄버거 사람 사람 햄버거 사람</p> <p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>4</strong> <strong>5</strong> <strong>6</strong> <strong>7</strong> <strong>8</strong> <strong>9</strong> <strong>10</strong> <strong>11</strong> <strong>12</strong></p> <p>K = 2인 경우에는 6명 모두가 햄버거를 먹을 수 있다.</p> <ul> <li>2번 위치에 있는 사람: 1번 위치에 있는 햄버거</li> <li>4번 위치에 있는 사람: 3번 위치에 있는 햄버거</li> <li>6번 위치에 있는 사람: 5번 위치에 있는 햄버거</li> <li>9번 위치에 있는 사람: 7번 위치에 있는 햄버거</li> <li>10번 위치에 있는 사람: 8번 위치에 있는 햄버거</li> <li>12번 위치에 있는 사람: 11번 위치에 있는 햄버거</li> </ul> <p>처음에 그리디로 생각했는데 9번의 경우 가장 가까운 값으로 먹으면 10번이 11번 햄버거를 먹어서 12번이 아무것도 못먹게 된다.</p> <p>그래서 백트래킹인건가? dfs로 각 P마다 1-K번 모두 점프 시도해보았다. (근데 가장 가까운 값을 먹는게 아니라 가장 작은 인덱스 값부터 먹는 그리디였으면 가능했다. )</p> <ul> <li>처음에는 한 칸 점프, 만약 K가 1보다 크면, 2칸 점프해서 dfs… K칸까지 점프하는 dfs 실행 후 Math.max로 출력</li> </ul> <ol> <li>String 에서 P를 찾아 이동 가능한 거리를 for문으로 돌면서 먹을 수 있는 지 확인한다.</li> <li>먹을 수 있으면 햄버거 eaten 표시와사람별로 먹었는지를 나타내는 pEaten를 True 표시한다.</li> <li>먹을 수 없거나 H면 idx+1해서 다음 dfs 실행한다.</li> <li>인덱스가 String 길이가 되면 종료</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">static</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">line</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">eaten</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">pEaten</span><span class="o">;</span>
    
<span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>

<span class="n">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">maxCnt</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxCnt</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'P'</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">matched</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">jump</span> <span class="o">=</span> <span class="o">-</span><span class="no">K</span><span class="o">;</span> <span class="n">jump</span> <span class="o">&lt;=</span> <span class="no">K</span><span class="o">;</span> <span class="n">jump</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">jump</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">[</span><span class="n">target</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'H'</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">eaten</span><span class="o">[</span><span class="n">target</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">// 먹기</span>
                    <span class="n">eaten</span><span class="o">[</span><span class="n">target</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                    <span class="n">eaten</span><span class="o">[</span><span class="n">target</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">matched</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">matched</span><span class="o">)</span> <span class="n">dfs</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span> <span class="c1">// 못 먹고 넘어감</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span> <span class="c1">// 사람이 아닌 경우 그냥 넘어감</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div> <p>는 시간초과가 난다. 백트래킹이고. 그리디도 시간복잡도는 O(20000*20)로 똑같을 것 같은데 아니었다.</p> <h2 id="코드-구현">코드 구현</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">eaten</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'P'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 앞뒤로 k칸 범위 탐색</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="no">K</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">+</span> <span class="no">K</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="no">N</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'H'</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">eaten</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">eaten</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">count</span><span class="o">++;</span>
                        <span class="k">break</span><span class="o">;</span> <span class="c1">// 한 사람은 햄버거 하나만 먹음</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="배우게-된-점">배우게 된 점</h2> <p>백트래킹은 시간복잡도가 더 작을 줄 알았는데.. 아니었다. 20개의 문자에 대해 K개의 선택을 하니까 20^K로 계산해야 한다.</p> <h2 id="질문">질문</h2>]]></content><author><name></name></author><category term="Algorithm"/><category term="백준"/><summary type="html"><![CDATA[문제 링크]]></summary></entry><entry><title type="html">[Java][BOJ 17484] 진우의 달 여행(small)</title><link href="https://github.com/Ahranah/blog/2025/Java-BOJ-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small/" rel="alternate" type="text/html" title="[Java][BOJ 17484] 진우의 달 여행(small)"/><published>2025-06-19T02:04:13+00:00</published><updated>2025-06-19T02:04:13+00:00</updated><id>https://github.com/Ahranah/blog/2025/Java-BOJ-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small</id><content type="html" xml:base="https://github.com/Ahranah/blog/2025/Java-BOJ-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small/"><![CDATA[<h2 id="문제-링크">문제 링크</h2> <h2 id="문제-파악">문제 파악</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/Boj/2025-06-19-java-boj-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small/img.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/Boj/2025-06-19-java-boj-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small/img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/Algorithm/Boj/2025-06-19-java-boj-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small/img_1.png" sizes="95vw"/> <img src="/assets/img/posts/Algorithm/Boj/2025-06-19-java-boj-17484-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-small/img_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>지구와 달 사이 공간의 행렬 N x M (2≤ N, M ≤ 6)에서 달 여행에 필요한 최소 연료 값을 출력하라</p> <ul> <li>같은 방향으로 두 번 이동할 수 없다.</li> </ul> <h2 id="접근-방법">접근 방법</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">.</span> <span class="n">dfs에서</span> <span class="n">y가</span> <span class="mi">7</span><span class="o">(</span><span class="n">높이</span><span class="o">)</span><span class="n">이되면</span> <span class="n">pq에</span> <span class="n">넣어</span> <span class="n">가장</span> <span class="n">적은</span> <span class="n">비용을</span> <span class="n">출력한다</span><span class="o">.</span>
<span class="mi">2</span><span class="o">.</span> <span class="n">dp는</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="n">i</span> <span class="n">행</span> <span class="n">j</span> <span class="n">열이</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span> <span class="n">or</span> <span class="n">j</span> <span class="n">or</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
</code></pre></div></div> <ol> <li> <p>같은 방향인지 확인하기 위해 dir를 노드에 추가하고, 이전과 같은 dir면 멈추는 조건을 추가해야 한다.</p> </li> <li> <p>재귀에서 탈출했을 때 visited false 처리</p> </li> </ol> <ul> <li>재귀는 stack처럼 동작하기 때문에 달을 찍고 return하면 두번째 뒤 점에서 다시 달까지 시도</li> </ul> <h2 id="코드-구현">코드 구현</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">dir</span><span class="o">;</span> <span class="c1">// 0, 1, 2 (좌하, 하, 우하)</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">dir</span> <span class="o">=</span> <span class="n">dir</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">v</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">coord</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

        <span class="n">coord</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>

        <span class="c1">// 행렬 생성</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
                <span class="n">coord</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 달에 도달한 노드 저장소</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">);</span>

        <span class="c1">// 첫 번째 행 모든 열에서 출발점 생성 후 dfs</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">coord</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>

            <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>

            <span class="n">v</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>  <span class="n">value</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span> <span class="c1">// 첫 direction은 겹치지 않도록 [0, 2]가 아닌 값</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Node</span> <span class="n">cur</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 좌, 하, 우</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

        <span class="c1">// 달에 닿으면 pq에 넣기</span>
        <span class="c1">// 아래로만 이동하기 때문에 depth가 필요없음</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">coord</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">v</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">coord</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">coord</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">]</span> <span class="o">||</span> <span class="n">cur</span><span class="o">.</span><span class="na">dir</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

                <span class="n">v</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">dfs</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">cur</span><span class="o">.</span><span class="na">v</span> <span class="o">+</span> <span class="n">coord</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">],</span> <span class="n">j</span><span class="o">));</span>
                <span class="n">v</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="배우게-된-점">배우게 된 점</h2> <ol> <li> <p>출발점에서 visited 초기화해주니까 재귀 탈출해서 v[y][x] = false 처리가 필요없는 줄 알았다.</p> </li> <li> <p>x, y가 col, row라 헷갈려서 잘못썼다.</p> </li> </ol> <h2 id="질문">질문</h2> <p>dp코드도 봐야겠다 복잡해보임 ㅠ</p> <p><a href="https://velog.io/@gkdbssla97/BOJ-17484.-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-Small-Java">https://velog.io/@gkdbssla97/BOJ-17484.-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-Small-Java</a></p> <p><a href="https://velog.io/@gkdbssla97/BOJ-17484.-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-Small-Java">[BOJ] 17484. 진우의 달 여행 (Small) - Java17484.진우의 달 여행 (Small) : https://www.acmicpc.net/problem/17484 문제 설명 지구에서 달까지 가기 위해 최소한의 연료를 사용해야한다. 7시, 6시, 5시 총 3방향으로 이동할 수 있으며 직전에 움직인 방향velog.io</a></p>]]></content><author><name></name></author><category term="Algorithm"/><category term="백준"/><summary type="html"><![CDATA[문제 링크]]></summary></entry></feed>