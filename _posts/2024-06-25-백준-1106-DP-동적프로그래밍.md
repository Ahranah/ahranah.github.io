---
layout: post
title: "[백준 1106] DP 동적프로그래밍"
date: 2024-06-25 18:05:41 +0900
categories: [Algorithm, 백준]
tags: [코딩, 알고리즘, dp, 백준, 동적프로그래밍, 백준1106]
---

동적 프로그래밍(Dynamic programming)이란 과거에 사용한 값을 중복해서 사용하는 경우에서 사용할 알고리즘을 말한다. 대표적으로 배낭 문제, 피보나치 수열이 있다. 
이전에 구해놓은 값을 재사용하기 때문에 재귀함수를 이용해야 한다. 

{% include figure.liquid loading="eager" path="assets/img/posts/2024-06-25-백준-1106-dp-동적프로그래밍/img.webp" class="img-fluid rounded z-depth-1" %}

재귀함수를 naive하게 사용하게 되면 시간, 공간복잡도가 폭발적으로 증가한다.
부분 문제에 대한 값을 미리 계산해놓고 한 번에 이용하는 것이 시공간 관점에서 효율적이다.
 

따라서 **Memoization(메모이제이션)**을 활용한다.

{% include figure.liquid loading="eager" path="assets/img/posts/2024-06-25-백준-1106-dp-동적프로그래밍/img_1.webp" class="img-fluid rounded z-depth-1" %}

같은 문제의 풀이를 재활용하는 방식인데, 재귀의 방법이 있다. 부분 문제에 대한 경우의 수를 모두 구할 건데, 이 때 재귀를 사용한다. 부분 문제를 넣고(1), 빼고(0) 에 대한 경우의 수를 구하는 것이다.

dp의 memoization은 하향식으로 메인에서 시작해 낮은 단계를 만들어가기 때문에 하향식이다.
 
자자 ㅡ 코드를 보자

```cpp
int fib[MAX] = {0};

int fibonacci (int n ) {
	if (n <=1 ) return n;
    //fib[n]이 존재하지 않는 경우에 위에서부터 만들어가면서 구하므로 하향식이다.
    if ( fib[n] ) return fib[n];
    else return fib[n] = fibonacci(n-1) + fibonacci(n-2);
    }
```

 

상향식 풀이는 Tabulation이라고 한다.
상향식 풀이는 f[0] = 0, f[1] = 1로 지정해놓고 이를 조합해서 f[n]을 구하는 방법이다.

---