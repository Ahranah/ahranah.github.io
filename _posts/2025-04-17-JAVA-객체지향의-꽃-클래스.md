---
layout: post
title: "[JAVA] 객체지향의 꽃: 클래스"
date: 2025-04-17 10:52:30 +0900
categories: [Computer Science, Object Oriented Programming]
tags: [자바, class, singleton, 생성자, static, 클래스, instance, 싱글톤, oop, java]
---

## OOP 프로그래밍이 뭘까요?

Object-Oriented Programming 에서 Object는 데이터(필드)와 메소드를 하나로 묶어서 사용하겠다는 개념입니다.

- Encapsulation → 정보 보안
- Inheritance → 유지보수 용이
- Polymorphism → 클래스 형변환: 실무에서 많이 사용

 

## 클래스 기본 구조

field, method, Constructor

- 필드와 메소드는 선택적으로 가질 수 있다.

```java
public class Car {
    String company = "현대자동차";
    String model;
    String color;
    int maxSpeed;

	// 생성자 선언하지 않으면 자동 선언된다.
    // 선언한 경우에는 필요한 경우에 대한 선언자를 만들어줘야 한다.
    Car(){}

    Car(String model){
        this.model = model;
    }

    Car(String model, String color){
        this.model = model;
        this.color = color;
    }

    Car(String model, String color, int maxSpeed){
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}
```

 

객체 생성에는 생성자 호출이 반드시 필요하다.

```java
public class CarExample {
    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = new Car("자가용");
        Car car3 = new Car("자가용", "빨강");
        Car car5 = new Car("버스", "핑크", 500);
```

 

## 클래스 선언 방법에 따른 멤버의 구분

인스턴스instance 멤버
객체 소속 멤버(객체 생성에만 사용 가능)
- field, method

정적static 멤버
클래스 고정 멤버(객체 없이도 사용 가능)
- 메소드 영역(static) 클래스에 고정적으로 위치하는 멤버

 

## static

클래스(바이트코드)가 클래스 loader에 의해 로딩되면 바로 메소드 영역(바이트코드를 저장 위치)에 고정된다. 클래스가 메모리 로딩되면 객체 생성없이 메소드나 필드를 바로 . 연산자로 접근해 사용 가능하다

→ 객체마다 가지고 필요가 없는 공용적인 값이나 메소드는 정적(static)으로 선언

- static field는 객체 생성 없이도 사용할 수 있기 때문에 생성자 초기화 작업을 하지 않음
- static block에서 인스턴스 멤버를 사용하고 싶으면 생성자로 객체 생성 후 참조 변수(this 불가)로 접근

```java
public class Calculator {
	String color; // 인스턴스: 계산기별로 색이 다를 수 있다.
	static double pi = 3.1450; // 스태틱: 값 고정
    static String info;
    
    void setColor(String color) this.color = color; // instance
    static int plus (int x, int y) return x+y; // static method
    
    static {
    	info = "pi is " + pi;
        
        // 객체 생성
    	Calculator cal = new Calculator();
    
        // instance member
        cal.color = pink;
    }
}
```

```java
double result1 = 10 * 10 * Calculator.pi;
int result2 = Calculator.plus(10,5);
```

 

## 인스턴스 멤버에 접근하기 위해 this 이용

> 생성자와 메소드의 매개변수명이 인스턴스 필드명과 동일한 경우 인스턴스 필드임을 강조하기 위해 사용

```java
package ch06.sec09;
public class Car {
    //필드 선언
    String model;
    int speed;
    
    //생성자 선언
    Car(String model) {
    this.model = model; //매개변수를 필드에 대입(this 생략 불가)
    }
    
    //메소드 선언
    void setSpeed(int speed) {
    this.speed = speed; //매개변수를 필드에 대입(this 생략 불가)
    }
    
    void run() {
    this.setSpeed(100);
    System.out.println(this.model + "가 달립니다.(시속:" + this.speed + "km/h)");
    }
}
```

- 필드는 초기값을 주지 않아도 자동 초기화된다.

## 

## 상수 선언 관례

```java
static final double EARTH_SURFACE_AREA = 5.147185403641517E8;

// 객체마다 저장할 필요도 없고, 값 변경도 필요없(여러 개의 값을 가지지 않)기 때문에 static && final
// snake 표기법
```

- final field에 초기값을 줄 방법은 필드 선언 시, 생성자에서 초기값 대입 뿐이다.

 

## 접근 제한자 / 패키지

패키지는 클래스의 일부분으로 클래스 식별 용도로 사용한다. 다른 패키지에 있는 클래스를 이용하려면 import 문을 이용해서 어떤 패키지 클래스를 사용할 것인지 명시해야 한다.

- 패키지에 속한 바이트코드 파일(.class)은 따로 떼어내어 다른 디렉토리로 이동할 수 없다.

Access Modifier
제한 범위
제한 대상

public
없음
클래스, 필드, 생성자, 메소드

protected
같은 패키지이거나 자식 객체
필드, 생성자, 메소드

(default)
같은 패키지
클래스, 필드, 생성자, 메소드

private
object 내부
필드, 생성자, 메소드

클래스는 public과 default(접근 제한자가 붙지 않은 상태)를 가질 수 있다. 

## 

필드는 private로 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 할 수 있다. → Encapsulation

객체 생성을 제한하고 싶으면 생성자를 private로 제한해 외부에서 new 연산자로 생성자를 호출할 수 없도록 막을 수 있다.

## → Encapsulation

 

예시로 애플리케이션 전체에서 한 개의 객체만 생성해서 사용하는 싱글톤 Singleton 패턴을 보자

```java
public class Singleton{ 
	private static Singleton singleton = new Singleton();

	private Singlgeton() {}
    
    public static Singleton getInstance() {
    	return singleton;
    }
}
```

1. static : 객체 생성이 불가능하니 내부 값을 객체 생성없이 이용할 수 있도록 하고, private 로 외부에서 static field 변경을 못하도록 막는다.
2. private 생성자를 선언해 외부에서 객체 생성이 불가능하도록 막는다.
3. public static method로 객체를 새로운 객체로 복사해서 사용할 수 있도록 선언한다.