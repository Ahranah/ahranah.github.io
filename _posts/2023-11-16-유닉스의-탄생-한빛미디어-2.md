---
layout: post
title: "유닉스의 탄생, 한빛미디어(2)"
date: 2023-11-16 14:06:14 +0900
categories: 대내외활동
---

1편에서는 분리가능한 볼륨을 지원하는 계층적 파일 시스템을 이해했다.

이어서 '2. 서로 호환되는 파일, 디바이스, 프로세스 간 입출력'과 '4. 사용자 단위로 선택 가능한 시스템 명령어'를 알아보겠다.

 

 우리는 보통 키보드, 마우스를 통해 데이터를 입력하고 모니터를 통해 출력 정보를 본다. 입출력은 명확하다. 프로그램을 실행하고자 한다면 마우스에서 크롬을 클릭하여 크롬을 실행할 수도 있고, 셸(Shell)을 이용해서 프로그램을 실행할 수도 있다. 셸이란 사용자가 명령어를 실행하도록 해주는 프로그램이자 사용자와 운영체제 간의 주된 인터페이스다. 인터페이스는 매개체? 정도로 이해할 수 있다. 셸은 운영체제에 필수 부분이 아닌 사용자 프로그램이라서 다양한 셸을 이용할 수 있다. 다양한 프로그램이어도 같은 구문 규칙을 이용한다. 이 부분이 사용자가 직접 선택할 수 있는 시스템 명령어에 해당한다.

 

 셸의 기능을 설명하며 "모든 셸이 파일명 와일드카드 - 패턴 메타문자가 패턴과 일치하는 파일명 목록으로 확장되는 기능-을 제공한다."라고 했다. 난해했다. 파일명을 확장한다는 것이 무엇일까... book*은 book으로 시작하는 모든 파일명으로 확장한다. 이름을 확장한다는 것은 무슨 의미일까... 

 

 메타문자부터 알아보자. 메타문자란 어떤 문자에 특별한 의미를 부여해서 복잡한 패턴을 명시하도록 하는 것이다. '*'은 앞에 오는 문자가 임의의 횟수로 반복된다는 패턴을 포함한 메타문자다. book*이면 book이 여러 번 반복되는 횟수만큼 파일명이 목록으로 확장된다. 이때 파일명을 전달 인자(argument)로 전달받는 명령어는 패턴(임의의 횟수로 반복)을 통해 명시되었다는 사실을 모른다. 그냥 book, book, book... 이 적힌 목록으로 인식한다. 이제 와일드카드를 이해할 수 있다. 메타문자가 패턴과 일치하는 파일명 목록으로 확장된다는 말은 만약에 #을 입력하면 #이 파일명에 적힌 숫자들과 같은 문자로 인식되는 것이다. 파일 3, 파일 4, 파일 8이 있다고 해보자. 그러면 우리는 '파일#'으로 적을 수 있는 것이다. 컴퓨터활용능력 자격증을 공부했다면 이해하기 쉬울 것 같다. 지금까지 다룬 텍스트의 패턴 표기는 정규표현식이라는 이름으로 불린다. 메타문자나 와일드카드 등등이 정규 표현식에 포함된 내용으로 이해하면 된다. 

 

셸은 입출력 리디렉션 기능을 제공한다. 프로그램 출력 내용을 명령어 한 줄로 파일에 저장할 수 있다. 내가 A 통로로 입력하면서 B통로로 출력하라는 명령을 했다고 하자. 셸 프로그램은 자동으로 B에서 출력값이 나올 수 있게 방향을 틀어준다. 덕분에 우리는 B에 한번 더 입력하는 행위를 하지 않아도 된다. 이처럼 반복적으로 하는 작업은 셸 스크립트라는 명령어 시퀀스에 넣어서 자동화할 수 있다. 아이폰에서 지원하는 shortcut이 떠올랐다. 프로그램의 출력값을 입력값으로 연결하는 개념은 파이프(pipe)이다. 예를 들어 현재 철수가 로그인했는지 알기 위해서 로그인된 사용자를 각각으로 행별로 출력한 값이 '철수'를 찾는 명령어에 입력되는 것이다. 셸에서 파이프 기능을 사용할 수 있다. 지금은 놀라울 것이 없는 내용이지만 당시에는 구현하기 까다로운 내용이었다고 한다. 프로그램 간에 흘러 다니는 데이터를 큐(대기 행렬)로 처리해야 하는데 잘못하다간 큐의 길이가 극단적으로 증가할 수 있기 때문이다. 이는 입출력 리디렉션을 위한 메커니즘을 응용해서 구현이 된다.

 

 입출력 리디렉션과 파이프는 어떻게 다른거지 헷갈렸다. 둘 다 같은 기능을 할 수 있다. 입출력 리디렉션은 임시 파일을 생성하고, 지워주는 번거로운 과정이 추가될 뿐이다. 만약 앞서 철수가 로그인했는지 알기 위한 명령어를 입출력 리디렉션을 이용해 구현한다면, 로그인된 사용자를 각각 행별로 출력한 값을 저장하는 임시파일을 생성하고, 이 임시파일을 '철수'라는 패턴을 찾는 명령어에 입력값으로 넣어주어야 한다.  

 

(서로 호환되는 파일, 디바이스, 프로세스 간 입출력의 구체적인 사례도 알아봐야겠다.)  

 

3. 비동기 프로세스를 시작하는 기능

 

 비동기는 작업들의 요청과 응답의 타이밍이 같지 않은 것을 말한다. 만약에 항목이 만 개쯤 되는 목록에서 특정 패턴이 포함된 항목을 추출하는 프로그램을 짰다고 하자. 필요한 양이 50개도 안된다면 목록을 모두 볼 이유는 없다. 컴퓨터는 추출하라고 요청하면 응답을 바로 하기 때문에 멈추라고 다시 요청하지 않는 이상 만 개를 확인할 것이다. 앨프리는 필요한 부분만 응답하도록 응답 타이밍을 지연시키는 전략을 생각해 낸다. 실행 속도를 높이는 눈부신 기술적 성과다. 

 

5. 십여 가지 언어를 포함하는 100개 이상의 서브시스템

 

 유닉스는 한 가지 기능에 집중하는 프로그램 여러개를 연결한 운영체제다. 다양한 언어를 이용해 특수 목적에 맞게 구현한 것도 있다. 예를 들면, 새벽 2시에 작업을 실행하라는 명령어를 만든 것이다. 이는 비전문가가 언어를 만들 수 있도록 해준 도구가 있었기에 가능했다. 사람보다 도구를 이용해 코드를 짜는 것을 추천했다고 한다. 나도 챗GPT를 애용한다. 

 

 초기 유닉스는 어셈블리어로 작성되었지만 고수준 언어인 C언어로 대다수 변환된다. 어셈블리어는 기계어에 가까운 low-level언어이기 때문에 작성하기에 문법도 복잡하고 직관적으로 이해하기 어려운 부분이 많다. 유닉스가 C언어로 변환되면서 특정 하드웨어에 갇히지 않고 이식성을 가지게 되면서 유닉스의 다양한 이점이 현재에 영향을 많이 주게 되었다. 리눅스도 유닉스 기반의 운영체제임을 생각하면 컴퓨터 공학도는 리눅스를 사용해 볼 필요가 있다. 리눅스에는 발전의 역사가 담겨있기 때문이다.