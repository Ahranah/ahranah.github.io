---
layout: post
title: "[Java][BOJ 11650] 좌표 (퀵)정렬하기"
date: 2025-10-08 23:59:38 +0900
categories: [Algorithm, 백준]
tags: [퀵정렬, 분할정복]
---

## 문제 링크

{% include figure.liquid loading="eager" path="assets/img/posts/Algorithm/Boj/2025-10-08-java-boj-11650-좌표-퀵-정렬하기/img.png" class="img-fluid rounded z-depth-1" %}

pivot을 정하면 그 위치는 딱 하나인데, 왜 확률을 곱해서 평균을 내지? 그때그때 n-1번 비교하는 거 아닌가요?

-> 그때그때 어떤 pivot이 선택될지 모르기 때문에 모든 경우를 평균적으로 고려해서 E[X] 계산을 하는거다.

만약 제일 작은 요소를 pivot으로 선택하면 왼쪽은 크기가 0, 오른쪽은 크기가 n-1이 부분 배열이 생겨서 최악의 시간 복잡도를 가진다.

## 문제 파악

2차원 평면 위의 점 N개를 x좌표, y좌표 순으로 증가하도록 정렬하라.

- 첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.

x 순으로 정렬하고, x가 같을 때 y를 비교하도록 한다. 

- 분할 -> 정복(정렬), 같을 때 분할 -> 정복(정렬)

## 접근 방법

**1. mergeSort**

원래 배열을 둘로 나누고, 나뉜 두 개의 배열을 비교해서 합치면서 정렬한다.

1. N의 중간값을 기준으로 배열 1, 배열 2로 나누어 받는다.
2. 재귀를 이용해 배열 하나에 [x, y]만 남도록 partition한다.
3. merge: 공통 배열에 배열 1과 2의 x값을 비교해 작은 값을 넣는다.
4. 만약 같다면 y값을 비교해 더 작은 것이 앞으로 가도록 한다.

**2. quickSort**

하나의 pivot을 무작위로 구해서, pivot 기준으로 좌측은 pivot보다 작게, 우측은 크게해서 배열을 둘로 쪼개고, 쪼개진 배열에서도 위와 같이 pivot을 구해 정렬한다. 

1. pivot을 선정해 pivot의 위치와 pivot 값을 기록한다.
2. i, j = 0 으로 놓는다. i는 for문을 도는값, j는 피벗보다 작은 값이 들어갈 범위의 마지막 인덱스다.
3. for문으로 배열의 [pivot index+1, ] 범위를 pivot item과 비교해 더 작으면 pivot과 swap한다.pivot과 동일하면 y값을 비교한다.pivot보다 작은 값이 들어갈 위치는 이전 마지막 인덱스 j 에  +1 해서 swap한다.
4. pivot이 들어가야할 최종 위치 j와 pivot이 원래 있었던 위치를 swap한다.

최종적으로 왼쪽은 pivot보다 작은 값, 오른쪽은 큰 값이 되었다. 이걸 partition 배열의 개수가 2인 칸까지 Top down한다 생각하면, 전체 sorting이 된다. 

## 코드 구현

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static class Node {
        int x, y;
        public Node(int x, int y){
            this.x = x;
            this.y = y;
        }
    }

    public static void swap(Node[] arr, int i, int j){
        Node temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }

    public static int partition(Node[] S, int low, int high){
        Node pivotItem = S[low];
        int j = low;

        for (int i = low + 1; i <= high; i++) {
            if (S[i].x < pivotItem.x || (S[i].x == pivotItem.x && S[i].y < pivotItem.y)) {
                j++;
                swap(S, i, j);
            }
        }
        swap(S, low, j);
        return j;
    }

    public static void quickSort(Node[] S, int low, int high){
        if(low < high){
            int pivotPoint = partition(S, low, high);
            quickSort(S, low, pivotPoint-1);
            quickSort(S, pivotPoint+1, high);
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        Node[] S = new Node[N];

        for(int i=0; i<N; i++){
            String[] tokens = br.readLine().split(" ");
            int x = Integer.parseInt(tokens[0]);
            int y = Integer.parseInt(tokens[1]);
            S[i] = new Node(x, y);
        }

        quickSort(S, 0, N-1);

        StringBuilder sb = new StringBuilder();
        for (Node n: S) {
            sb.append(n.x).append(" ").append(n.y).append("\n");
            // System.out.println(n.x + " " + n.y); // IO마다 호출해서 느림
        }
        System.out.print(sb);
    }
}
```

## 배우게 된 점

시간초과났지만 알고리즘이니까 이러케 풀겠따.

Java 내장 정렬로 아주 간단히 풀 수도 있다. 이렇게하면 시간초과 안난다.

- Arrays.sort()는Dual-Pivot QuickSort로 평균 성능 매우 우수
- JVM이 최적화 해줌 (입력 정렬 상태에 따라 다른 알고리즘 사용)

```java
        Arrays.sort(S, (a, b) -> {
            if (a.x != b.x) return a.x - b.x;
            else return a.y - b.y;
        });
```

## 질문