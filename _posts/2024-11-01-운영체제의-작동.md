---
layout: post
title: "운영체제의 작동"
date: 2024-11-01 23:36:08 +0900
categories: [Computer Science, Operating System]
tags: [OS, CPU, memory, Process, 클라우드컴퓨팅, bootstrap, interrupt, kernel, 파일시스템, scheduling]
---

운영체제는 시스템 자원의 효율적인 관리와 안전한 접근이다.

컴퓨터의 전원을 켜거나 재부팅할 때와 같이 컴퓨터를 실행하려면 초기 프로그램을 실행해야 한다.

# 부트스트랩(초기프로그램)

펌웨어에 저장된 단순한 형태의 부트스트랩은 CPU 레지스터, 장치 컨트롤러, 메모리 내용 등 시스템의 모든 측면을 초기화한다.
부트스트랩은 OS 커널을 찾아 메모리에 적재하는 방법과 해당 시스템 실행 시작 방법을 알아야 한다.

커널이 RAM에 로드되면 시스템과 사용자에게 서비스를 제공할 수 있다. OS는 이벤트가 없는 경우 조용히 앉아 기다리게 되는데 이벤트는 거의 항상 **인터럽트**를 발생시켜 신호를 보낸다.

# 인터럽트

인터럽트는 하드웨어 인터럽트와 trap이 있다. 트랩은 예외 상황(유효하지 않은 메모리 액세스)에 대한 오류이거나 소프트웨어 생성 인터럽트로 나뉜다.

소프트웨어 생성 인터럽트: 사용자 프로그램이 시스템 콜(특정 요청)로 운영체제의 동작을 요구하는 것

# multiprogramming & multitasking

사용자는 일반적으로 두 개 이상의 프로그램을 돌리려고 한다. 이는 CPU가 쉬지 않아야(바쁘게 유지해야) 실행할 수 있는 것으로 프로그램의 인스턴스인 **프로세스**를 여러 개 동시에 메모리에 유지하여 실행하게 된다.
CPU는 여러 프로세스를 전환하며 사용자에게는 빠른 **응답 시간**을 제공하고, 사용자의 응답을 대기하는 동안 다른 프로세스를 처리하며 쉬지 않는다.
동시에 여러 프로세스를 메모리에 올리다보면 **메모리 관리** 가 필요하고, 또한 다음에 수행할 프로세스를 고르기 위한 **CPU 스케쥴링**도 필요하다. 여러 프로세스를 병행 처리하기 위한 프로세스 스케쥴링, 디스크 및 저장장치 관리 등 운영체제 모든 단계에서 서로 영향을 미치는 기능에 대해 다뤄야 한다.

- 메모리 관리: Virtual memeory: 일부만 메모리에 적재된 프로세스의 실행을 허용하여 물리적인 메모리 한계를 고려하지 않고 시스템을 이용한다.
- 그 외, 파일 시스템, 동기화, 보호, race condition 등도 고려한다.

# Multimode operation

운영체제는 사용자와 컴퓨터 시스템의 하드웨어 및 소프트웨어를 공유한다. 프로그램이나 운영체제의 동작이 시스템을 악의적으로 잘못 실행하는 것을 막기 위해 하드웨어 자원에 접근하는 방식에 다양한 실행 모드를 두는 것이다. 적어도 사용자, 커널 두 개로는 나눈 연산 모드를 가져야 한다. 시스템에 운영체제를 위한 작업과 사용자를 위한 작업을 분리하는 것이다.

## 사용자 모드

실행중인 사용자 프로세스가 시스템 콜을 호출하면 시스템 콜이 trap을 걸어 커널 모드에 진입한다.

## 커널 모드(privileged mode)

커널 모드와 사용자 모드는 모드 비트 0과 1로 구분할 수 있으며 커널 모드에서 시스템 콜이 가진 특정 하드웨어 요청을 수행한 뒤 모드 비트를 1로 변경해 사용자 모드로 복귀한다.

부팅과정) 하드웨어 커널 모드에서 시작해 운영체제가 적재되고 사용자 모드에서 사용자 프로세스가 시작된다. trap이나 인터럽트가 발생할 때마다 하드웨어는 상용자 모드에서 커널 모드로 전환하며 운영체제가 컴퓨터의 제어를 얻을 때마다 커널 모드에 있게 된다. 시스템이 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 전환한다.

# 시스템 콜

시스템 콜은 운영체제가 하도록 지정된 작업을 사용자 프로그램이 수행해야 할 때 사용자 프로세스가 운영체제에게 해달라고 요청하는 것을 말한다. 시스템 콜은 하드웨어에 의해 소프트웨어 인터럽트로 간주되어 interrupt 벡터를 통해 운영체제 내부 특정 위치로 trap을 건다. 모드 비트가 0으로 변경되고 커널 모드에 진입해 전달받은 서비스 루틴을 수행한다.

시스템 콜 서비스 루틴은 운영체제의 일부다. 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 콜이 발생했는지 결정한다. 이때 전달된 인수가 사용자 프로그램이 요청하는 서비스 유형을 표시한다.

요청이 불법적인 명령이나 주소 공간 외 메모리 영역을 접근하려고 한다면 하드웨어는 운영체제로 트랩을 걸어 프로그램 비정상 종료시킨다. 이때의 트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에 넘기는 것이다. ^ 종료시키는 것도 운영체제가 하는 일이다. 이때 **적절한 오류 메세지**를 주어 수정해 다시 실행시킬 수 있도록 기록된다.

# Timer

cpu의 무한 루프를 방지하고, 제어가 os로 돌아오지 않을 상황을 대비해 지정 시간 후 컴퓨터를 인터럽트 하도록 설정할 수 있다.

# 프로세스 관리

프로그램과 프로세스를 분리해야 한다. 프로그램은 저장된 파일의 내용인 수동적 개체고, 프로세스는 다음 수행할 명령을 지정하는 **program counter**를 가진 능동적 개체다. 프로세스는 한 시스템의 작업 단위로, 반드시 순차적으로 수행되어야한다. CPU는 프로세스의 명령을 차례대로 수행한다. 두 개의 프로세스가 동일한 프로그램에 연관되어 있어도 다른 수행 순서로 간주한다.

프로세스는 운영체제 프로세스(시스템 코드)와 사용자 프로세스로 구성된다.
운영체제는 프로세스 관리와 연관해
**- 사용자 프로세스와 시스템 프로세스 생성과 제거**
**- CPU에 프로세스와 스레드 스케쥴링**
**- 프로세스 ready, dispatch, running**
**- 프로세스 동기화 기법**
**- IPC 프로세스 통신**
에 책임을 진다.

# 메모리 관리

메인 메모리는 CPU, I/O 장치에 의해 공유되는 빠른 접근이 가능한 데이터 저장소다. CPU가 직접 접근할 수 있단 의미는 CPU가 직접 메모리 주소를 지정할 수 있고, CPU의 프로세스 수행을 위해선 메인 메모리에 적재되어 있어야 한다는 말이다.

프로그램 수행을 위해선 절대 주소로 mapping되고 메모리에 적재되어 있어야 한다. 메모리에 여러 개의 프로그램을 유지해야 하기 위해선 메모리 관리 기법이 필요하다. 상황에 따라 다른 알고리즘을 이용할 수 있으며 실행에는 하드웨어의 지원이 필요하다.
운영체제가 메모리 관리에 담당하는 일
**- 메모리의 어느 부분이 사용되고 있으며 어느 프로세스에 의해 사용되고 있는지 추적**
**- 필요에 따라 메모리 공간 할당과 회수**
**- 어떤 프로세스를 적재하고 제거할 것인지 결정**

# 파일 시스템 관리

파일 시스템은 시스템을 편리하게 쓰고자 만든 개념이다. 저장장치의 물리적 특성은 추상화하고 논리적인 저장 단위인 파일을 정의한다.
운영체제가 파일(프로그램와 데이터)을 물리적 매체(저장장치)에 mapping 하며, 저장장치를 통해 이 파일에 접근한다.

저장 장치는 디스크, 메모리 등 다양한 메모리 저장소를 의미한다.
파일의 정의: 파일 생성자에 의해 생성된 관련 정보의 집합체

저장 장치는 기기마다 특성(접근 속도, 용량, 데이터 전송률)이 다르고 디스크 드라이브와 같은 장치에 의해 제어된다.
운영체제는 이 저장 장치와 제어 장치(드라이브)를 관리함으로써 파일의 추상적인 개념을 구현한다. 파일은 사용하기 쉽도록 **디렉터리로** 구성되어 있고 파일에 접근할 때에는 누가, 어떤 권한(read, write, execute)으로 접근할 것인지를 통제한다.
운영체제가 파일 관리를 위해 담당하는 일
**- 파일, 디렉터리의 생성 및 제거**
**- 파일을 보조저장장치에 매핑**
**- 파일 백업**

# Mass-Storage Management

대용량 저장장치 = 보조저장장치 (HDD, NVM)
메인 메모리 백업을 위해 보조저장 장치를 이용한다. 컴파일러, 웹 브라우저, 워드 프로세서 등 프로그램의 대부분은 메모리에 적재될 때까지 보조저장장치에 저장되고, 프로그램이 장치를 처리 소스, 대상으로 사용한다. 보조저장장치는 매우 빈번하고 폭넓게 사용되므로 효율적으로 사용해야 한다. 컴퓨터의 전체 동작 속도는 보조저장장치 서브시스템과 그 알고리즘의 속도에 의해 결정될 수 있기 때문이다.
3차 저장장치 CD, Blu-ray 등은 시스템 성능에 그리 중요하지 않지만 운영체제에 의해 마운트, 언마운트, 장치 할당, 반환, 데이터 이주 등이 관리되어야 한다.

운영체제가 보조저장장치 관리에 담당하는 일
**- 마운팅, 언마운팅**
**- free-space 관리**
**- 저장장소 할당, 분할**
**- 디스크 스케쥴링**

# 캐시 관리

캐시는 CPU 성능 최적화를 위한 메모리로 초고속 접근이 필요하다. 더 빠른 장치인 캐시에 데이터가 올라가 있어야 프로그램 속도도 빨라진다. 캐시에 정보가 없다면 메인 메모리로부터 가져와서 사용해야 하며 이 정보는 다시 사용될 확률이 높다는 가정하에 캐시에 넣는다. 프로그래머(컴파일러)는 어느 정보를 메인 메모리에 두고, 어느 정보를 레지스터에 둘 건지 결정하는 레지스터 할당 및 교체 알고리즘을 구현한다.
캐시와 레지스터의 데이터 전송은 속도 때문에 하드웨어적으로 이뤄진다.
메모리 계층 구조에서, 다중 태스킹 환경이라면 하나의 데이터가 동시에 여러 로컬 캐시에서 변경되는 상황에 **캐시 일관성 문제**가 일어날 수 있다. 이는 보통 운영체제보다 아래 수준인 하드웨어적으로 처리된다.

# I/O Systems Management

운영체제는 **입출력 서브시스템**을 이용해 사용자에게 하드웨어 장치의 특성을 숨긴다. 오로지 장치 드라이버만이 자신에게 지정된 특성 장치의 특성을 알고 있다.
입출력 시스템은 버퍼링, 캐싱, 스풀링 등의 메모리 관리 구성요소, 장치 드라이버 인터페이스, 하드웨어 드라이버로 구성된다.

# Security and Protection

Protection은 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 또는 사용자의 **접근**을 제어하는 기법이다.
Security는 외부 또는 내부의 공격에 방어하는 것이다.

공격에는 바이러스, 웜, DoS(자원을 다 소모해서 다른 사용자가 접근하지 못하게 하는), 식별자 도용 등이 있다.

다수 프로세스의 병행 수행에는 데이터 일관성 문제를 위해 데이터 접근을 규제해야 한다. 파일, 메모리 세그먼트, CPU 및 다른 자원들에 대해 운영체제로부터 허가를 획득한 프로세스만이 작업을 보장해 주는 기법이 필요하다.

## 사용자 구분

운영체제의 대부분은 사용자 이름과 관련된 사용자 식별자 user** ID**의 리스트를 유지한다.

- 로그인할 때 인증 단계에서 사용자에 맞는 식별자가 결정되고 이 식별자는 사용자의 모든 프로세스나 스레드에 연관된다.
- 사용자는 운영체제 설계에 따라 하나 이상의 그룹에 속한다.어떤 상황에서는 각 사용자가 아닌 사용자 집합을 구분해야 하기 때문에 그룹 이름과 그룹 식별자 groupID의 리스트를 구현한다.식별자로는 사용자와 그룹으로 충분하다. 그러나 때때로 원하는 작업 수행을 위해 권한 상승이 필요하면 유효 사용자 식별자 effectiveuser ID를 이용한다.
- 사용자가 제한된 장치에 접근할 때 운영체제는 권한 상승을 위해 현 사용자가 아닌 파일의 소유주 식별자 setuid 속성을 이용해 동작할 수 있다.
- 프로세스는 종료되거나 특권을 해제하기 전까지 effective user ID를 이용해 수행된다.

# 가상화

가상화는 운영체제가 다른 운영체제 내에서 하나의 응용처럼 수행될 수 있게 한다.

## Virtualization vs. Emulation

에뮬레이션은 소프트웨어로 하드웨어를 시뮬레이션하는 것을 말한다. 일반적으로 CPU가 다른 두 기기에 대해 하나의 응용 소프트웨어를 확장해서 사용할 수 있게 하기 위함이다.

- Apple 사가 IBM Power CPU에서 Intel x86로 전환했을 때 "Rosetta"라는 에뮬레이터로 IBM 용으로 컴파일된 응용을 인텔에서 수행할 수 있도록 했다.에뮬레이션은 비슷한 CPU 기준 원래 코드보다 훨씬 느리고, 모든 명령에 대해 동등 기능으로 변역 되어야 하기 때문에 가상화가 이점을 가진다.가상화에서는 특정 CPU를 위해 컴파일된 운영체제가 동일 CPU용 다른 운영체제 내에서 수행된다.가상 머신(VMware)은 운영체제 간 전환이 프로세스 간 전환하는 방식으로 이뤄지도록 한다.

{% include figure.liquid loading="eager" path="assets/img/posts/2024-11-01-운영체제의-작동/img.png" class="img-fluid rounded z-depth-1" %}

 

가상화가 CPU, 메모리, 디스크 드라이브, 네트워크 등 하드웨어를 여러 실행 환경으로 추상화하여 개별 환경이 독립적인 컴퓨터 환경에서 실행되는 것처럼 만드는 기술이다. Windows는 호스트 운영체제고, VMware가 응용 형태(guest의 환경)로 수행되는 가상화 기술을 만들었다. VMM(가상머신관리자)는 게스트 운영체제를 수행하고 그들의 자원을 관리하며 각 게스트를 서로로부터 보호한다. 

 

## 클라우드 컴퓨팅

계산, 저장, 응용 소프트웨어 등을 네트워크를 통한 서비스로 제공하는 컴퓨팅 유형이다. 어떤 면에서 클라우드 컴퓨팅은 가상화를 기능의 기반으로 사용하기 때문에 가상화의 논리적 확장이다. 

- 컴퓨팅 - 서버 유형은 클라이언트가 어떤 작업을 요청하면 서버가 작업을 수행한 결과를 돌려보내는 시스템이다.
- SaaS (Software) : 워드나 스프레드시트
- PaaS (Platform) : 데이터베이스 서버
- IaaS (infra) : 백업 복사본을 위한 저장 장치

{% include figure.liquid loading="eager" path="assets/img/posts/2024-11-01-운영체제의-작동/img_1.png" class="img-fluid rounded z-depth-1" %}

클라우드 하부구조 내에 전통적인 운영체제가 있고, 그 위에는 사용자 프로세스가 수행되는 virtual machines의 관리자 VMM이 있다. 더 위로는 클라우드 관리 도구가 VMM을 관리한다. 이 도구들은 클라우드 자원, 구성요소들에 대한 인터페이스를 제공하므로 이들을 새로운 운영체제로 볼 수도 있다. 

*방화벽: 보안 침해로부터 보호하기 위해 네트워크 장치 간 통신을 제한한다.