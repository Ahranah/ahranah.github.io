---
layout: post
title: "[JAVA] 참조형 : 배열 초기화, 복사"
date: 2025-04-16 10:58:19 +0900
categories: [Computer Science, Object Oriented Programming]
tags: [java, array]
---

Data Type

Primitive Type
Reference Type

정수 
실수
논리
Array
Enum
Class
Interface

byte
char
short
int
long
float
double

boolean
 

 

참조형에서 가장 많이 사용되는 배열을 보자. 

{% include figure.liquid loading="eager" path="assets/img/posts/2025-04-16-java-참조형-배열-초기화-복사/img.png" class="img-fluid rounded z-depth-1" %}

 

배열은 마지막 인덱스에 length를 가진다. 배열은 크기가 정해지면 변경할 수 없다.  

{% include figure.liquid loading="eager" path="assets/img/posts/2025-04-16-java-참조형-배열-초기화-복사/img_1.png" class="img-fluid rounded z-depth-1" %}

배열명(배열 변수:scores)는 stack에 저장되어 heap 영역에 생성된 배열을 참조하는 방식으로 이용한다. 배열 변수(scores)는 힙 영역의 배열 주소를 저장한다. 따라서 인덱스로 접근할 수 있다.

배열 내부는 같은 type 값으로 관리하나, 해당 배열이 가리키는 주소의 객체 타입은 다를 수 있다.

 

## 배열 초기화

```java
// 정적 초기화
String season = {"Spring", "Summer", "Fall", "Winter"} ;

// 동적 초기화
// null로 초기화시 stack에만 생성되고 참조하는 배열이 없기 때문에 new로 초기화하여 사용해야 한다.
int[] scores = null;
scores = new int[30];
```

{% include figure.liquid loading="eager" path="assets/img/posts/2025-04-16-java-참조형-배열-초기화-복사/blob.jpg" class="img-fluid rounded z-depth-1" %}

- new를 이용한 배열 초기화 시 초기값이 0, false, null 로 초기화된다.

```java
String names = new String[30];
```

{% include figure.liquid loading="eager" path="assets/img/posts/2025-04-16-java-참조형-배열-초기화-복사/img_2.png" class="img-fluid rounded z-depth-1" %}

 

## 배열 복사

primitive type의 경우 값을 복사해서 사용하기 하지만 참조형은 해당 주소만 복사해 같은 객체를 사용할지, 객체를 복사해 새로운 객체로 사용할지 나누어 복사할 수 있다. 

- 기본형 == 연산자: 값 비교
- 참조형 ==연산자: 주소 자체 비교객체의 내용이 같은지 확인할 때는 .equals()를 이용한다.

#### 얕은 복사: 주소 복사 - 같은 값을 가리키게 됨

```java
int[] n1 = {100, 200, 300};
int[] n2 = n1;
```

 

#### 깊은 복사 : 주소가 가리키는 값 복사 - 복사된 새로운 객체를 가리키게 됨

```java
// clone()
// 객체 배열에서는 값 자체(주소)를 복사하기 때문에 얕은 복사처럼 보일 수 있다.

int[] array = {1, 2, 3, 4, 5};
int[] clonedArray = array.clone(); // 복사
System.out.println(Arrays.toString(clonedArray)); // [1, 2, 3, 4, 5]
```

```java
// System.arraycopy()
int[] src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int[] dest = new int[5]; // 크기 5짜리 배열 생성
System.arraycopy(src, 0, dest, 0, 5); // src[0]~src[4]를 dest[0]~dest[4]로 복사
System.out.println(Arrays.toString(dest)); // [1, 2, 3, 4, 5]
```

```java
// Array.copyof()
int[] original = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int[] copied = Arrays.copyOf(original, 7); // 처음 7개 복사
System.out.println(Arrays.toString(copied)); // [1, 2, 3, 4, 5, 6, 7]
```

```java
// for문 복사
int[] source = {1, 2, 3, 4, 5};
int[] destination = new int[source.length];
for (int i = 0; i < source.length; i++) {
    destination[i] = source[i];
}
System.out.println(Arrays.toString(destination)); // [1, 2, 3, 4, 5]
```

깊은 복사는 새로운 객체를 만들고 값을 받아온 것이기 때문에 참조형 == 연산자: 주소 비교에서 다른 주소를 가진다는 결과가 나온다.

- .equals() 비교는 true