---
layout: post
title: "[Java][프로그래머스] 신고 결과 받기"
date: 2025-05-30 00:41:41 +0900
categories: [Algorithm, 프로그래머스]
---

## 문제 파악

매개변수

- 이용자의 ID가 담긴 문자열 배열 id_list <= 1000["muzi", "frodo", "apeach", "neo"]
- 각 이용자와 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열 report <= 200000["muzi frodo","apeach frodo","frodo neo","muzi neo","apeach muzi"]
- 정지 기준이 되는 신고 횟수 k

각 유저는 다른 유저를 신고할 수 있다(중복 신고는 가능하나 신고 1회로 처리). 이때 신고를 k번 이상 받으면 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송한다.

id_list에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 배열로 담아 return

## 접근 방법

1. String[] report -> Set<String> report 중복처리

2. Map<String, Integer> reportedMap : report에서 신고횟수 누적

3. int[] mailList : id_list 순서대로 report containsKey()로 나온 value가 reportedMap에 존재하는지 확인 후 메일 개수 추가

## 코드 구현

```java
import java.util.*;

class Solution {
    
    public int[] solution(String[] id_list, String[] report, int k) {
        Set<String> report_set = new HashSet<>(Arrays.asList(report));
        
        //Map<String, Set<String>> report_map = new HashMap<>();
        Map<String, Integer> reported = new HashMap<>();
        
        for(String rep : report_set){
            String[] row = rep.split(" ");
            reported.put(row[1], reported.getOrDefault(row[1], 0)+1);
        }
        
        int[] answer = new int[id_list.length];
            
            for(String rep : report_set){
                String[] row = rep.split(" ");
                    if(reported.get(row[1]) >= k) {
                        int idx = Arrays.asList(id_list).indexOf(row[0]);
                        answer[idx] ++;
                    }
                }
 
        return answer;
    }
}
```

## 배우게 된 점

return 배열이 id_list 순서대로 해야하니 idx 를 구하기 위해 Arrays.asList(id_list).indexOf(id) 부분을 잘 활용해야 한다.

## 질문