---
layout: post
title: "관계 데이터 모델 기본 개념과 제약 조건"
date: 2024-10-23 16:22:37 +0900
categories: [Computer Science, DataBase]
tags: [제약조건, 후보키, 기본키, 외래키, 슈퍼키, 무결성제약조건]
---

## DBMS 기본 아키텍처: ANSI/SPARC

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_1.png" class="img-fluid rounded z-depth-1" %}

외부: 사용자 : 자신만의 뷰를 가지고 디비 이용

--

[ 외부/ 개념 mapping ] sql 질의어를 관계대수로 전환하는 등 질의 수준 변환

논리적인 데이터 독립성: 개념 스키마 변경에도 사용자는 영향 받지 않음

--

개념: 사용자 공동체가 보는 개념 스키마 
 - 어떤 데이터가 어떤 관계, 우떤 무결성 제약 조건을 가지는 지 정의 (EMP(ENO: INT, PROJ: STR ~) ...)
- 데이터 베이스 당 한 개의 개념 스키마만 존재함

--

[개념/ 내부 mapping] 질의를 디스크 디비 접근하기 위해 변환

물리적인 데이터 독립성: 내부 변화에도 개념 스키마의 변화는 없도록

--

내부: 물리적으로 데이터를 어떻게 저장할 지 - 보통 성능향상을 위하면 내부 스키마 변경이 바람직
 - 비순서파일로 저장되어 있음
- 저장 구조 변경하거나 인덱스 생성/ 삭제

## DB API

ODBC: 서로 다른 데이터 베이스 시스템을 통합하기 위해 마이크로소프트가 개발한 DB API

JDBC: 자바 운영 플랫폼에서 지원되는 API

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/Screenshot 2024-10-23 at 5.20.47 PM.png" class="img-fluid rounded z-depth-1" %}

## DBMS 종류

 

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_2.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_3.png" class="img-fluid rounded z-depth-1" %}

구조화되어 있지 않은 데이터가 폭발적으로 증가하면서 반구조/비구조적인 빅데이터를 다룰 필요성이 크게 높아졌다. 

=> **Not Only SQL - NoSQL**

 

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/Screenshot 2024-10-23 at 4.27.48 PM.png" class="img-fluid rounded z-depth-1" %}

 

**클라이언트-서버 데이터베이스 시스템**
데이터베이스 시스템 기능이 서버와 클라이언트에 분산된 구조
클라이언트는 PC, 노트북, 스마트폰 등으로 사용자 인터페이스 관리와 응용을 수행하고
서버는 DBMS를 운영하면서 클라이언트에서 온 질의를 최적화 - 권한 수행 - 동시성 제어와 회복 - 무결성 유지 - 접근 관리를 수행한다. 

장점 : 접근이 뛰어남 
단점: 보안 취약

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_4.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_5.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_6.png" class="img-fluid rounded z-depth-1" %}

 

2층 모델이 있고 3층 모델이 있음. 
3층 모델은 데이터베이스 서버와 클라이언트 사이에 응용 서버가 존재하는 것
 - 데이터 처리만을 다루는 서버를 따로 두는 느낌

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_7.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/img_8.png" class="img-fluid rounded z-depth-1" %}

 

공식 용어
자주 사용되는 용어
파일 시스템 용어

Relation
테이블
파일

Tuple
레코드/행
레코드

Attribute
컬럼/속성/열
필드

*null: 모름. 적용할 수 없음.

# Relation schema (intension)

EMP(last_name, first_name, salary ... ) 기본 틀(framework)를 의미한다.

# Relation instance (extension)

튜플의 집합 EMP = `{{'emily', 'blunt', 5,000,000..), ('john', 'cr~", ...) }`

relation schema가 모여서 **relation database schema**, relation instance가 모여서 **relation database instance**가 된다.

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/Screenshot 2024-10-23 at 4.19.29 PM.png" class="img-fluid rounded z-depth-1" %}

# Relation

릴레이션 릴레이션 - 테이블 - 파일 ... 은 사실 튜플(행)의 집합이다.

## 릴레이션의 특징

- 각 릴레이션은 하나의 레코드 타입만 포함(3, 'school', 'springfield') - (숫자, 문자, 문자) 같은 타입의 순서를 의미
- 한 애트리뷰트 내 값은 모두 같은 유형
- 동일 튜플이 두 개 이상 존재하지 않음 = 키
- 애트리뷰트의 순서는 중요하지 않음
- 각 애트리뷰트는 원자값을 가짐

## 

## 릴레이션의 키

super key { candidate key ( alternate key | primary key )} - foreign key

{% include figure.liquid loading="eager" path="assets/img/posts/2024-10-23-관계-데이터-모델-기본-개념과-제약-조건/Screenshot 2024-10-23 at 4.21.46 PM.png" class="img-fluid rounded z-depth-1" %}

식별성 - 최소성 -> 대리 키로 표현할 수도 있다.

- 외래키는 참조되는 릴레이션의 기본 키와 동일한 도메인을 가져야 함
- 외래키의 값은 다른 테이블의 기본키 or 자기 테이블의 기본키 or null 을 가짐

# 

# 무결성 제약 조건

## 데이터 무결성 integrity

DBMS에서 자동으로 검사하기 때문에 따로 검사할 필요는 없음

## 도메인 constraint

애트리뷰트 값이 반드시 원자값이어야 한다.

- CHECK 제약 조건, default를 통해 값의 범위를 제한할 수 있다 .

## 키 constraint

키 애트리뷰트에는 중복값을 가져선 안 된다.

### 기본키와 entity integrity constraint

기본 키 애트리뷰트에 속하는 값은 null을 가질 수 없음 -> 기본 키 명시 필요

- 대체 키에는 적용되지 않는다.

### 외래키와 referential integrity constraint

두 릴레이션이 튜플들 간에 일관된 값을 가지도록 한다.

주로 Manupulation: DML에 값을 수정, 조작할 때 문제가 많이 일어나므로 조치를 취해준다.

- INSERT, DELETE, UPDATE

외래키를 가지는 (참조하는) | 기본키를 가지는 (참조되는) 으로 나눠서 생각할 수 있다.
INSERT의 경우, 참조하는 테이블에 값을 넣는 것이 문제가 된다. 참조되는 테이블에 없는 값을 넣으면 안 되니깐
DELETE의 경우, 참조되는 테이블이 값을 삭제하는 것이 문제 - 참조하고 있는데 갑자기 사라지면 안되니깐
UPDATE는 삭제 후 삽입이므로 기본적으로 외래키, 기본키를 확인하는 조치를 해준다.

**참조 무결성 제약조건을 위한 DBMS의 선물**
값을 수정할 때마다 어떤 값을 넣을 수 있고, 등등의 조건을 확인하면 너무 품이 많이 든다. 그래서 무결성을 지켜주기 위한 DMBS의 선물이 있다.

1. Restricted : 위배되는 연산을 거절한다.

2. CASCADE : 참조되는 테이블에서 삭제할 때 그냥 참조하는 테이블 값도 지워버린다.

3. NULL : 참조되는 테이블에서 삭제하는 값을 다른 테이블에서 참조하고 있다면 null로 취해준다.

4. DEFAULT: null 대신 default로 설정된 값을 삽입한다.
